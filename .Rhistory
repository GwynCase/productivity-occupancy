class.name=c('ocean', 'freshwater', 'river',
'nil', 'low', 'moderate', 'high'))
# Add levels to raster.
levels(r.hsi) <- hsi.levels
# Assign crs to raster.
crs(r.hsi) <- CRS('+proj=utm +zone=10 +datum=NAD83 +units=m +no_defs')
# Define landscape sizes.
landscape <- data.frame(
size=c('PFA', 'breeding area', 'home range', 'maximum range'),
area=c(60, 200, 3800, 15600)
)
# Convert area in hectares to radii in meters.
landscape <- landscape %>% mutate(radius=sqrt(area*10000/pi))
# Read in the data.
nests <- read_csv('../data/processed/sc_nests.csv')
# Calculate a centroid for each site, and keep only ones with a quality index.
centroids <- nests %>% group_by(site) %>%
mutate(mean.x=mean(xcoord), mean.y=mean(ycoord)) %>%
distinct(site, name, mean.x, mean.y)
sites <- semi_join(centroids, data, by=c('site', 'name')) %>%
rename(xcoord=mean.x, ycoord=mean.y)
# Make it a spatial object for later.
sites.sf <- sites %>%
st_as_sf(coords=c('xcoord', 'ycoord')) %>%
st_set_crs('+proj=utm +zone=10 +datum=WGS84 +units=m +no_defs') %>%
st_as_sf()
# Also make a list of site names for later.
site.names <- sites.sf$site
# Make a list of metrics to calculate.
hsi.metrics <- c('lsm_l_sidi')
# Make a function to do the calculations and formatting.
calc.hsi.metrics <- function(x) {
sample_lsm(r.hsi, y=sites.sf, size=x, plot_id=site.names, shape='circle',
what=hsi.metrics) %>%
left_join(hsi.levels, by=c('class'='ID')) %>%
mutate(class.name=ifelse(is.na(class.name), metric, class.name)) %>%
select(-class, -metric, -level) %>%
pivot_wider(names_from=class.name, values_from=value) %>%
mutate(radius=x) %>%
rename(hsi.inside=percentage_inside)
}
# Run the function for each sample size.
hsi.landscape.metrics <- map_df(landscape$radius, calc.hsi.metrics)
# Do some cleanup
hsi.landscape.metrics <- hsi.landscape.metrics %>%
select(radius, hsi.inside, nest=plot_id, hsi.diversity=sidi)
hsi.landscape.metrics <- select(landscape, radius, size) %>% right_join(hsi.landscape.metrics, by=c('radius'))
# Join to data frame.
df <- left_join(df, hsi.landscape.metrics, by=c('site'='nest', 'size', 'radius', 'hsi.inside'))
# Filter out any sites without sufficient landscape coverage.
df <- df %>% filter_at(vars(contains('inside')), all_vars(. >=90))
# Proportion suitable
proportion.suitable.model <- function(df) {
glm(cbind(years.detect, years.no.detect) ~ proportion.suitable, data=df, family=binomial(logit))
}
# Proportion suitable + HSI diversity
suitable.diversity.model <- function(df) {
glm(cbind(years.detect, years.no.detect) ~ proportion.suitable + hsi.diversity, data=df, family=binomial(logit))
}
# Proportion suitable + suitable edge density
suitable.edge.density.model <- function(df) {
glm(cbind(years.detect, years.no.detect) ~ proportion.suitable + suitable.edge.density, data=df, family=binomial(logit))
}
# Proportion suitable + HSI diversity + suitable edge density
suitable.sink.model <- function(df) {
glm(cbind(years.detect, years.no.detect) ~ proportion.suitable +
suitable.edge.density + hsi.diversity, data=df, family=binomial(logit))
}
# Proportion mature forest
proportion.mature.model <- function(df) {
glm(cbind(years.detect, years.no.detect) ~ proportion.cover.mature, data=df, family=binomial(logit))
}
# Proportion mature + landcover diversity
mature.diversity.model <- function(df) {
glm(cbind(years.detect, years.no.detect) ~ proportion.cover.mature + cover.diversity, data=df, family=binomial(logit))
}
# Proportion mature + gap edge density
mature.edge.density.model <- function(df) {
glm(cbind(years.detect, years.no.detect) ~ proportion.cover.mature + gap.edge.density, data=df, family=binomial(logit))
}
# Proportion mature + gap edge density + landcover diversity
mature.sink.model <- function(df) {
glm(cbind(years.detect, years.no.detect) ~ proportion.cover.mature +
gap.edge.density + cover.diversity, data=df, family=binomial(logit))
}
# Null
null.model <- function(df) {
glm(cbind(years.detect, years.no.detect) ~ 1, data=df, family=binomial(logit))
}
# Nest the data frame.
nf <- df %>% group_by(size) %>% nest()
# Apply the functions.
nf <- nf %>%
mutate(
m.proportion.suitable=map(data, proportion.suitable.model),
m.suitable.diversity=map(data, suitable.diversity.model),
m.suitable.edge.density=map(data, suitable.edge.density.model),
m.suitable.sink=map(data, suitable.sink.model),
m.proportion.mature=map(data, proportion.mature.model),
m.mature.diversity=map(data, mature.diversity.model),
m.mature.edge.density=map(data, mature.edge.density.model),
m.mature.sink=map(data, mature.sink.model),
m.null=map(data, null.model)
)
all.models <- nf %>% pivot_longer(-c(size, data), names_to='modname', values_to='model') %>%
mutate(name=paste(size, modname))
aictab(all.models$model, modnames=all.models$name) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
View(df)
df %>% filter(years.detect == 0)
df %>% filter(years.detect == 0) %>%
distinct(name, .keep_all=TRUE)
df %>% filter(years.detect == 0) %>%
distinct(name, .keep_all=TRUE) %>%
select(site, name, years.surveyed, years.detect, years.no.detect)
pfa.models <- nf %>% filter(size == 'PFA') %>%
pivot_longer(-c(size, data), names_to='modname', values_to='model')
ba.models <- nf %>% filter(size == 'breeding area') %>%
pivot_longer(-c(size, data), names_to='modname', values_to='model')
hr.models <- nf %>% filter(size == 'home range') %>%
pivot_longer(-c(size, data), names_to='modname', values_to='model')
mr.models <- nf %>% filter(size == 'maximum range') %>%
pivot_longer(-c(size, data), names_to='modname', values_to='model')
aictab(pfa.models$model, modnames=pfa.models$modname) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
# Separate out the data.
pfa.data <- df %>% filter(size == 'PFA')
# Re-write the top model on its own.
pfa.top.model <- glm(cbind(years.detect, years.no.detect) ~ proportion.suitable, data=pfa.data, family=binomial(logit))
# Create a grid and add predictions.
pfa.predicted <- data_grid(pfa.data, proportion.suitable, .model=pfa.top.model) %>%
mutate(pred=predict(pfa.top.model, newdata=., type='response'))
# Grab the inverse link function from the model.
inv <- family(pfa.top.model)$linkinv
# Add fit and SE data.
pfa.predicted <- bind_cols(pfa.predicted, setNames(as_tibble(predict(pfa.top.model, pfa.predicted,
se.fit = TRUE)[1:2]),
c('fit.link','se.link')))
# Create confidence interval.
pfa.predicted <- pfa.predicted %>% mutate(fit.resp  = inv(fit.link),
right.upr = inv(fit.link + (2 * se.link)),
right.lwr = inv(fit.link - (2 * se.link)))
# Plot them?
ggplot(pfa.predicted, aes(x=proportion.suitable, y=pred)) +
geom_line() +
geom_ribbon(aes(ymin=right.lwr, ymax=right.upr), alpha=0.1) +
geom_point(data=pfa.data, aes(x=gap.edge.density, y=quality.index)) +
theme_classic()
# Plot them?
ggplot(pfa.predicted, aes(x=proportion.suitable, y=pred)) +
geom_line() +
geom_ribbon(aes(ymin=right.lwr, ymax=right.upr), alpha=0.1) +
geom_point(data=pfa.data, aes(x=proportion.suitable, y=quality.index)) +
theme_classic()
summary(pfa.top.model)
# Look at some diagnostics.
data.frame(predicted=predict(pfa.top.model, type='response'),
residuals=residuals(pfa.top.model, type='response')) %>%
ggplot(aes(x=predicted, y=residuals)) +
geom_point() +
geom_hline(yintercept=0, linetype='dashed') +
geom_smooth(method='lm', se=FALSE, color='black') +
theme_classic()
pfa.models %>% mutate(glance=map(model, glance)) %>%
unnest(glance) %>% ungroup() %>%
select(!c(size, data, model))
pfa.models %>% mutate(tidy=map(model, tidy)) %>%
unnest(tidy) %>% ungroup() %>%
select(!c(size, data, model)) %>%
filter(term != '(Intercept)')
aictab(ba.models$model, modnames=ba.models$modname) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
# Separate out the data.
ba.data <- df %>% filter(size == 'breeding area')
# Re-write the top model on its own.
ba.top.model <- glm(cbind(years.detect, years.no.detect) ~ proportion.suitable +
hsi.diversity, data=ba.data, family=binomial(logit))
# Create a grid and add predictions.
ba.predicted <- data_grid(ba.data, hsi.diversity, .model=ba.top.model) %>%
mutate(pred=predict(ba.top.model, newdata=., type='response'))
# Grab the inverse link function from the model.
ba.inv <- family(ba.top.model)$linkinv
# Add fit and SE data.
ba.predicted <- bind_cols(ba.predicted, setNames(as_tibble(predict(ba.top.model, ba.predicted,
se.fit = TRUE)[1:2]),
c('fit.link','se.link')))
# Create confidence interval.
ba.predicted <- ba.predicted %>% mutate(fit.resp  = ba.inv(fit.link),
right.upr = ba.inv(fit.link + (2 * se.link)),
right.lwr = ba.inv(fit.link - (2 * se.link)))
# Plot them?
ggplot(ba.predicted, aes(x=hsi.diversity, y=pred)) +
geom_line() +
geom_ribbon(aes(ymin=right.lwr, ymax=right.upr), alpha=0.1) +
geom_point(data=ba.data, aes(x=hsi.diversity, y=quality.index)) +
theme_classic()
summary(ba.top.model)
# Look at some diagnostics.
data.frame(predicted=predict(ba.top.model, type='response'),
residuals=residuals(ba.top.model, type='response')) %>%
ggplot(aes(x=predicted, y=residuals)) +
geom_point() +
geom_hline(yintercept=0, linetype='dashed') +
geom_smooth(method='lm', se=FALSE, color='black') +
theme_classic()
ba.models %>% mutate(glance=map(model, glance)) %>%
unnest(glance) %>% ungroup() %>%
select(!c(size, data, model))
ba.models %>% mutate(tidy=map(model, tidy)) %>%
unnest(tidy) %>% ungroup() %>%
select(!c(size, data, model)) %>%
filter(term != '(Intercept)')
aictab(hr.models$model, modnames=hr.models$modname) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
aictab(hr.models$model, modnames=hr.models$modname) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
# Separate out the data.
hr.data <- df %>% filter(size == 'home range')
# Re-write the top model on its own.
hr.top.model <- glm(cbind(years.detect, years.no.detect) ~ proportion.cover.mature +
gap.edge.density + cover.diversity, data=df, family=binomial(logit))
summary(hr.top.model)
# Create a grid and add predictions.
hr.predicted <- data_grid(hr.data, gap.edge.density, .model=hr.top.model) %>%
mutate(pred=predict(hr.top.model, newdata=., type='response'))
# Grab the inverse link function from the model.
hr.inv <- family(hr.top.model)$linkinv
# Add fit and SE data.
hr.predicted <- bind_cols(hr.predicted, setNames(as_tibble(predict(hr.top.model, hr.predicted,
se.fit = TRUE)[1:2]),
c('fit.link','se.link')))
# Create confidence interval.
hr.predicted <- hr.predicted %>% mutate(fit.resp  = hr.inv(fit.link),
right.upr = hr.inv(fit.link + (2 * se.link)),
right.lwr = hr.inv(fit.link - (2 * se.link)))
# Plot them?
ggplot(hr.predicted, aes(x=gap.edge.density, y=pred)) +
geom_line() +
geom_ribbon(aes(ymin=right.lwr, ymax=right.upr), alpha=0.1) +
geom_point(data=hr.data, aes(x=gap.edge.density, y=quality.index)) +
theme_classic()
hr.models %>% mutate(glance=map(model, glance)) %>%
unnest(glance) %>% ungroup() %>%
select(!c(size, data, model))
hr.models %>% mutate(tidy=map(model, tidy)) %>%
unnest(tidy) %>% ungroup() %>%
select(!c(size, data, model)) %>%
filter(term != '(Intercept)')
aictab(mr.models$model, modnames=mr.models$modname) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
# Separate out the data.
mr.data <- df %>% filter(size == 'maximum range')
# Separate out the data.
mr.data <- df %>% filter(size == 'maximum range')
# Re-write the top model on its own.
hr.top.model <- glm(cbind(years.detect, years.no.detect) ~ proportion.cover.mature +
gap.edge.density + cover.diversity, data=hr.data, family=binomial(logit))
# Create a grid and add predictions.
hr.predicted <- data_grid(hr.data, gap.edge.density, .model=hr.top.model) %>%
mutate(pred=predict(hr.top.model, newdata=., type='response'))
# Grab the inverse link function from the model.
hr.inv <- family(hr.top.model)$linkinv
# Add fit and SE data.
hr.predicted <- bind_cols(hr.predicted, setNames(as_tibble(predict(hr.top.model, hr.predicted,
se.fit = TRUE)[1:2]),
c('fit.link','se.link')))
# Create confidence interval.
hr.predicted <- hr.predicted %>% mutate(fit.resp  = hr.inv(fit.link),
right.upr = hr.inv(fit.link + (2 * se.link)),
right.lwr = hr.inv(fit.link - (2 * se.link)))
# Plot them?
ggplot(hr.predicted, aes(x=gap.edge.density, y=pred)) +
geom_line() +
geom_ribbon(aes(ymin=right.lwr, ymax=right.upr), alpha=0.1) +
geom_point(data=hr.data, aes(x=gap.edge.density, y=quality.index)) +
theme_classic()
summary(hr.top.model)
# Create a grid and add predictions.
mr.predicted <- data_grid(mr.data, gap.edge.density, .model=mr.top.model) %>%
mutate(pred=predict(mr.top.model, newdata=., type='response'))
# Re-write the top model on its own.
mr.top.model <- glm(cbind(years.detect, years.no.detect) ~ proportion.cover.mature +
gap.edge.density + cover.diversity, data=mr.data, family=binomial(logit))
# Create a grid and add predictions.
mr.predicted <- data_grid(mr.data, gap.edge.density, .model=mr.top.model) %>%
mutate(pred=predict(mr.top.model, newdata=., type='response'))
# Grab the inverse link function from the model.
mr.inv <- family(mr.top.model)$linkinv
# Add fit and SE data.
mr.predicted <- bind_cols(hr.predicted, setNames(as_tibble(predict(mr.top.model, mr.predicted,
se.fit = TRUE)[1:2]),
c('fit.link','se.link')))
# Add fit and SE data.
mr.predicted <- bind_cols(mr.predicted, setNames(as_tibble(predict(mr.top.model, mr.predicted,
se.fit = TRUE)[1:2]),
c('fit.link','se.link')))
# Create confidence interval.
mr.predicted <- mr.predicted %>% mutate(fit.resp  = mr.inv(fit.link),
right.upr = mr.inv(fit.link + (2 * se.link)),
right.lwr = mr.inv(fit.link - (2 * se.link)))
# Plot them?
ggplot(mr.predicted, aes(x=gap.edge.density, y=pred)) +
geom_line() +
geom_ribbon(aes(ymin=right.lwr, ymax=right.upr), alpha=0.1) +
geom_point(data=mr.data, aes(x=gap.edge.density, y=quality.index)) +
theme_classic()
summary(hr.top.model)
mr.models %>% mutate(glance=map(model, glance)) %>%
unnest(glance) %>% ungroup() %>%
select(!c(size, data, model))
mr.models %>% mutate(tidy=map(model, tidy)) %>%
unnest(tidy) %>% ungroup() %>%
select(!c(size, data, model)) %>%
filter(term != '(Intercept)')
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE)
# Import conflict settings.
source('../src/conflicted.R')
# Load some libraries.
library(tidyverse)
library(lme4)
library(broom)
library(modelr)
library(MuMIn)
library(knitr)
library(kableExtra)
# Load in the habitat variables prepped earlier.
ls <- read_csv('../data/processed/landscape_metrics_full.csv')
# And load in the productivity data.
pd <- read_csv('../data/raw/productivity.csv')
# Join them together, keeping just sites with productivity data.
df <- left_join(pd, ls)
View(df)
pr.qi <- distinct(df, site, n.fledge, quality.index)
View(pr.qi)
pr.qi <- distinct(df, site, year, n.fledge, quality.index)
pr.b.qi <- lmer(n.fledge ~ quality.index + (1|year), data=pr.qi)
summary(pr.b.qi)
# Cover diversity
landcover.model <- function(df) {
lmer(n.fledge ~ cover.diversity + (1|site), data=df)
}
# High canopy cover
canopy.model <- function(df) {
lmer(n.fledge ~ canopy.high + (1|site), data=df)
}
# BEC diversity
bec.model <- function(df) {
lmer(n.fledge ~ bec.diversity + (1|site), data=df)
}
# Proportion suitable
suitable.model <- function(df) {
lmer(n.fledge ~ proportion.suitable + (1|site), data=df)
}
# Gap edge density
gap.model <- function(df) {
lmer(n.fledge ~ gap.edge.density + (1|site), data=df)
}
# Nest the data frame.
nf <- df %>% group_by(size) %>% nest()
# Apply the functions.
nf <- nf %>%
mutate(
landcover=map(data, landcover.model),
canopy=map(data, canopy.model),
bec=map(data, bec.model),
suitable=map(data, suitable.model),
gap=map(data, gap.model)
)
# Cover diversity
landcover.model <- function(df) {
lmer(n.fledge ~ cover.diversity + (1|year), data=df)
}
# High canopy cover
canopy.model <- function(df) {
lmer(n.fledge ~ canopy.high + (1|year), data=df)
}
# BEC diversity
bec.model <- function(df) {
lmer(n.fledge ~ bec.diversity + (1|year), data=df)
}
# Proportion suitable
suitable.model <- function(df) {
lmer(n.fledge ~ proportion.suitable + (1|year), data=df)
}
# Gap edge density
gap.model <- function(df) {
lmer(n.fledge ~ gap.edge.density + (1|year), data=df)
}
# Nest the data frame.
nf <- df %>% group_by(size) %>% nest()
# Apply the functions.
nf <- nf %>%
mutate(
landcover=map(data, landcover.model),
canopy=map(data, canopy.model),
bec=map(data, bec.model),
suitable=map(data, suitable.model),
gap=map(data, gap.model)
)
# Twist and assess.
nf.long <- nf %>%
pivot_longer(-c(size, data), names_to='modname', values_to='model') %>%
mutate(glance=map(model, glance)) %>%
mutate(rsq=map(model, r.squaredGLMM)) %>%
mutate(rsq=map(rsq, as.data.frame))
# Take a look.
nf.long %>% unnest(glance) %>%
unnest(rsq) %>%
select(-model, -data) %>%
arrange(AIC) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
# Twist and assess.
nf.long <- nf %>%
pivot_longer(-c(size, data), names_to='modname', values_to='model') %>%
mutate(glance=map(model, glance)) %>%
mutate(rsq=map(model, r.squaredGLMM)) %>%
mutate(rsq=map(rsq, as.data.frame))
# Take a look.
nf.long %>% unnest(glance) %>%
unnest(rsq) %>%
select(-model, -data) %>%
arrange(AIC) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
# Look at them.
df %>% distinct(site, quality.index, year, n.fledge)
# Proportion suitable
proportion.suitable.model <- function(df) {
lmer(n.fledge ~ proportion.suitable + (1|year), data=df)
}
# Proportion suitable + suitable edge density
suitable.edge.density.model <- function(df) {
lmer(n.fledge ~ proportion.suitable + suitable.edge.density + (1|year), data=df)
}
# Proportion mature forest
proportion.mature.model <- function(df) {
lmer(n.fledge ~ proportion.cover.mature + (1|year), data=df)
}
# Proportion mature + landcover diversity
mature.diversity.model <- function(df) {
lmer(n.fledge ~ proportion.cover.mature + cover.diversity + (1|year), data=df)
}
# Proportion mature + gap edge density
mature.edge.density.model <- function(df) {
lmer(n.fledge ~ proportion.cover.mature + gap.edge.density + (1|year), data=df)
}
# Proportion mature + gap edge density + landcover diversity
mature.sink.model <- function(df) {
lmer(n.fledge ~ proportion.cover.mature +
gap.edge.density + cover.diversity + (1|year), data=df)
}
# Null
null.model <- function(df) {
lmer(n.fledge ~ (1|year), data=df)
}
# Nest the data frame.
nf <- df %>% group_by(size) %>% nest()
# Apply the functions.
nf <- nf %>%
mutate(
m.proportion.suitable=map(data, proportion.suitable.model),
m.suitable.edge.density=map(data, suitable.edge.density.model),
m.proportion.mature=map(data, proportion.mature.model),
m.mature.diversity=map(data, mature.diversity.model),
m.mature.edge.density=map(data, mature.edge.density.model),
m.mature.sink=map(data, mature.sink.model),
m.null=map(data, null.model)
)
# Twist and assess.
nf.long <- nf %>%
pivot_longer(-c(size, data), names_to='modname', values_to='model') %>%
mutate(glance=map(model, glance)) %>%
mutate(rsq=map(model, r.squaredGLMM)) %>%
mutate(rsq=map(rsq, as.data.frame))
# Take a look.
nf.long %>% unnest(glance) %>%
unnest(rsq) %>%
select(-model, -data) %>%
arrange(AIC) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
# Twist and assess.
nf.long <- nf %>%
pivot_longer(-c(size, data), names_to='modname', values_to='model') %>%
mutate(glance=map(model, glance)) %>%
mutate(rsq=map(model, r.squaredGLMM)) %>%
mutate(rsq=map(rsq, as.data.frame))
# Take a look.
nf.long %>% unnest(glance) %>%
unnest(rsq) %>%
select(-model, -data) %>%
arrange(R2m) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
# Take a look.
nf.long %>% unnest(glance) %>%
unnest(rsq) %>%
select(-model, -data) %>%
arrange(desc(R2m)) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
all.models <- nf %>% pivot_longer(-c(size, data), names_to='modname', values_to='model') %>%
mutate(name=paste(size, modname))
aictab(all.models$model, modnames=all.models$name) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
library(AICcmodavg)
aictab(all.models$model, modnames=all.models$name) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
all.models <- nf %>% pivot_longer(-c(size, data), names_to='modname', values_to='model') %>%
mutate(name=paste(size, modname))
aictab(all.models$model, modnames=all.models$name) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
all.models <- nf %>% pivot_longer(-c(size, data), names_to='modname', values_to='model') %>%
mutate(name=paste(size, modname))
aictab(all.models$model, modnames=all.models$name) %>%
kable() %>% kable_styling(bootstrap_options=c('striped'))
